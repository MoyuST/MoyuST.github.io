---
layout: post
title: 第二章 第七节 编译与底层
date: 16/12 2021
permalink: /notes/nowcoder/chap2sec7/
---

## C++源文件从文本到可执行文件经历的过程

摘抄至[Mr_H9527](https://blog.csdn.net/Mr_H9527/article/details/81156112)

- 预处理
  去掉代码注释，对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。
- 编译
  生成汇编文件
- 汇编
  转换成机器码，生成可重定位目标文件
- 链接
  链接多个目标文件及所需要的库生成可执行目标文件

  - 合并段
    将重定位目标文件的每个段合并，调整段偏移
  - 符号重定位
    将每个可重定位目标文件的符号表合并解析，需要给每个符号加适当偏移量以确保对应其虚拟内存位置。ELF文件中，有一个叫重定位表的结构专门用来保存这些与从定位有关的信息，重定位表在elf文件中往往是一个或多个段

## include 头文件顺序

对于include的头文件来说，如果在文件a.h中**声明**一个在文件b.h中**定义**的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。

### 变量声明

变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。  
当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 **extern** 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。
类似于函数的prototype

### include的""与<>

双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。

- 对于使用双引号包含的头文件，查找头文件路径的顺序为：
  **- 当前头文件目录**
  - 编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）
  - 系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径
- 对于使用尖括号包含的头文件，查找头文件的路径顺序为：
  - 编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）
  - 系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径

## malloc原理

Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用**内存池**的方式，先申请**大块内存作为堆区**，然后将堆区分为**多个内存块**，以块作为内存管理的基本单位。当用户申请内存时，**直接从堆区分配一块合适的空闲块**。Malloc采用**隐式链表**结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用**显示链表**结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。

### 隐式链表

感谢qqliyunpeng，[他的博客写得很详细](https://blog.csdn.net/qqliyunpeng/article/details/91407705)  
Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。

## C/C++的虚拟内存管理

![C/C++内存分配](Assets/imgs/C_C++_内存分配.png)

3G用户空间和1G内核空间

32bitCPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中0~3G是用户态空间，3~4G是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其划分如下：

各个段说明如下：

- 静态区域：
  - text segment(代码段):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。
  - data segment(数据段)：存储程序中已初始化的全局变量和静态变量
  - bss segment：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0
- 动态区域：
  - heap（堆）： 当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。
  - memory mapping segment(映射区):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）
  - stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。

